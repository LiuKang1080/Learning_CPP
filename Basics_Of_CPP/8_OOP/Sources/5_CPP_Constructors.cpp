// Advanced Topics of the C++ Constructor

/*
Default Constructor
    - Does not take any arguments. Also called the no-args constructor.
    - If we do not provide a defualt constructor, then C++ will generate a defualt constructor that does nothing.
    - The defualt constructor is called when you initialize a new object with no arguments.
    
    - ex) 

        public: 
            Account() {
                name = "None";
                balance = 0.00;
            }

    - Now we can make a constructor that takes in arguments:

        public:
            Account(std::string name_val, double bal) {
                name = name_val;
                balance = bal;
            }

    - Once a constructor is defined for the class, C++ will NOT generate a defualt constructor. If we need to use a defualt
        constructor then we need to manually define the defualt constructor along with the other constructors.
    - Generally we want to provide our own defualt constructor.

Overloaded Constructors:
    - Classes can have as many constructors as needed.
    - Each constructor must have a unique signature.
    - The compiler must determine which constuctor is called based on the the initialization information provided when creating
        objects. If there is any ambiguity the compiler will NOT guess which constructor is called, and it will throw an error.
    - Defualt constructor will no longer be automatically generated by the compiler once another constructor is declared.
    - The best programming practice is to initialize all class attributes such that that no attributes contain any garbage data.

Constructor Initialization Lists:
    - So far all of the data members have been set to specific values in the constructor body.
    - There is a better way to initialize member values. We can do so with constructor initialization lists.
        - More efficient.
        - Initialization lists follows the parameter list.
        - Initializes the data members as the object is created.
        - The order of the initialization is the order of declaraction in the class

    - The member values that we set values within the constructor body technically isn't initialization. When the constructor is
        called the member values have already been created. In the constructor we are just assigning the values to the member
        values that have already been created, it's not true initialization.

    - We want the member values to be created and initialized with the proper values we give them before any of the constructors
        are called. (initialization lists is a true initialization of the member values)

        OLD WAY:

            class Player {
            private:
                std::string name;
                int health;
                int xp;

            public:
                // constructors:
                Player();
                Player(std::string name_val);
                Player(std::string name_val, health_val, xp_val);
            };

            Player::Player() {
                name = "None";      // this is assignment, not initialization
                health = 0;
                xp = 0;
            }

        BETTER WAY:

            Player::Player() 
            : name{"None"}, health{0}, xp{0} {
            } 
            
    - The order that the member are initialized is the order that they're declared in the class declaration.

        OLD WAY:

            Player::Player(std::string name_val) {
                name = name_val;
                health = 0;
                xp = 0;
            }

        BETTER WAY:

            Player::Player(std::string name_val)
            : name{name_val}, health{0}, xp{0} {
            }

        // 3 args constructor

            Player::Player(std::string name_val, int health_val, int xp_val)
            : name{name_val}, health{health_val}, xp{xp_val} {
            }

    - Notice that there is no code within the code block following the initializatin list within the constructor body. We can
        implement code within the code body if we need to.

Delegating Constructors:
    - Often the code for the constructors are similar.
    - Duplicate code within constructors will result in errors.
    - C++ allows delegating constructors 
    - Code for one constructor that can call another in the initialization list. Avoids duplicate code.
    - General syntax: After the parameter list we have the : following this is the call to the constuctor we wish to call.

    - 3 args constructor

        Player::Player(std::string name_val, int health_val, int xp_val)
            : name{name_val}, health{health_val}, xp{xp_val} {
                std::cout << "3 args constructor is called. \n";
        }

        - this is the 3 args constructor with the standard member initialization list
    
    - No args constructor: When we build the no args constructor we will call the 3 args constructor and pass in the initialization
        data we need.
    - We provide the constructor name which is the same name as the class followed by the arguments to the constructor.

        Player::Player()
            : Player { "None", 0, 0 } {
                std::cout << "no args constructor is called. \n";
        }

        - The no args constructor is the delegating constructor since it is delegates object initialization to another constructor

    - single args constructor: 

        Player::Player(std::string name)
            : Player {name_val, 0, 0} {
                std::cout << "1 args constructor is called \n";
        }

        - Once again the single args constructor is the delegating constructor, it will call the 3 args constructor and pass in
            the arguments provided.
    
    - Note that this only works in the initialization list, we cannot call the other constructors from the body in the delegating
        constructors.
    - You cannot delegate to another constructor and provide initialization values to class members.
    - In this example both of the constructors are delegating to the 3 args constructor.

    - Remember that when delegation happens to another constructor whatever code is within the constructor that is called will be
        executed. ex) When the no args constructor is called it will delegate to the 3 args constructor first and the first thing
        that prints is "3 args constructor is called." then the rest of the code within the no args constructor will execute
        printing "no args constructor is called."

Constructor Parameters and Defualt Values:
    - Default constructor parameters have the same rules as non-member functions (regular functions).
    - ex)

        class Player {
        private:
            std::string name;
            int health;
            int xp;
        
        public:
            Player(std::string name_val="None", int health_val=0, int xp_val=0);
        };

    - Single constructor with 3 args and has defualt values.
    - The implementation of the constructor will look like:

        Player::Player(std::string name_val, int health_val, int xp_val)
            : name{name_val}, health{health_val}, xp{xp_val} {
        }

    - We do not supply the defualt parameters here in the implementation.
    - Remember that the implementation of the constructor is outside of the class initialization.
    - Rather than having multiple constructors overloading, we can have a single/few (as long as it's not ambigous to the compiler),
        with default parameters that does the job of several constructors.
*/


#include <iostream>


int main() {

    return 0;
}
