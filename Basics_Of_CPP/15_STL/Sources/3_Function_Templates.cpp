// Generic Programming With Function Templates in C++

/*
Generic Programming - Function Templates:
    - A Template is a blueprint.
    - There are 2 types of Templates: Function Templates, and Class Templates.
    - Allows plugging in ANY data types.
    - The compiler generates the appropriate function / class from the blueprint.
    - This is how we're going to do Generic Programming / Meta Programming

    - Templates in theory are easy, but it practice it can become very complex.
    - The compiler error messages can be very complicated.

        int max(int a, int b) {
            return (a > b)? a: b;
        }

    - This function is only for ints, what about a function for floats, doubles, chars, etc?
    - We would need to make a function for each of those data types...
    - The only thing that changes is the data type, the logic / program is the same.
    - We use templates to make only 1 blueprint.

    - We want to replace the data type we want to generalize with a name, say T 

        T max(T a, T b) {
            return (a > b)? a: b;
        }

    - BUT, this will not compile, we need to tell the compiler that it needs to treat this function as a template.
    - We also need to tell the compiler that T is the template parameter.

        template <typename T>
        T max(T a, T b) {
            return (a > b)? a: b;
        }

    - This tells the compiler that the typename T will be replaced with whatever the user needs.
    - This will compile, BUT it will NOT generate any code!
    - Code is NOT generated by compiler until a user uses a specialized version of the template.
    - We can also use class OR typename keywords when creating a template:

        template <class T>
        T max(T a, T b) {
            return (a > b)? a: b;
        }

    - We will see both class and typename in production level code. We will be using the typename keyword.

Using a Template:
    
        int a {10};
        int b {20};

        std::cout << max<int>(a, b);

    - The compiler generates the proper function with the actual data type when we use the function.
    - This happens at compile time!
    - Many times the compiler can deduce the data type and the template parameter is not needed.
    - Depending on the data type of a and b, the compiler can figure it out by itself.
    
        std::cout << max<double>(a, b);
        std::cout << max(a, b);             // no need for the template parameter data types

    - We can use ALMOST any data type we need, BUT it needs to make sense!

Multiple Template Parameters:
    - We can have multiple template parameters, and their data types can be different.

        template <typename T1, typename T2>
        void func(T1 a, T2 b) {
            std::cout << a << " " << b << "\n";
        }

    - When we use the function, we can provide the template parameters, but often the compiler can deduce them by itself.

        func<int, double>(10, 20.2);
        func('A', 12.4);

    - For very complex situations, the compiler might not be able to figure out the data type for the template. In situations
        like that, we would need to make sure ourselves for the proper data types.
*/


#include <iostream>


// template: max function
template <typename T>
T max(T a, T b) {
    if (a > b) {
        return a;
    } else {
        return b;
    }
}

// template: swap 2 elements function
template <typename T>
void swap_elements(T &a, T &b) {
    T temp = a;
    a = b;
    b = temp;
}


int main() {
    // using the template:
    double a = 10.50;
    double b = 20.75;
    int x = 100;
    int y = 200;
    
    // we don't need to explicitly declare the data type for the template parameter, the compiler can do it for us
    std::cout << max<double>(a, b) << "\n";
    std::cout << max(x, y) << "\n";
    
    // swap 2 elements:
    int c = 50;
    int d = 75;

    std::cout << "Before swap: " << c << ", " << d << "\n";
    swap_elements(c, d);
    std::cout << "After swap: " << c << ", " << d << "\n";

    return 0;
}
